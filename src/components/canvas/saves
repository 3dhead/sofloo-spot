  drawCircle(ctx) {
    const {
      height,
      steps,
      width
    } = this.props;

    const coloredPixels = [];
    for (let i = 0; i < width; i++) {
      coloredPixels[i] = [];
    }

    // First we color the inner radius fully.
    
    // const innerRadius = 30;

    // const radius = 220;

    const centerX = 200;
    const centerY = 200;

    const stepLength = 30;

    const imageData = ctx.createImageData(width, height);

    console.log('Drawing a circle centered at', centerX, centerY);
    console.log('With a radius of', stepLength * steps);
    console.log('In an array the size of', width, height);

    const pixelDrawQueue = [];

    const drawPixelOfCircleRecursively = (x, y, step, lengthInStep) => {
      // Mark this pixel as painted.
      coloredPixels[x][y] = true;

      // if (Math.random()* 100 > 99) {
      //   console.log('Drawing', x, y);
      // }

      const pixelIndex = (y * width + x) * 4;
      
      // console.log('Color pixel at index:', x, y);

      imageData.data[pixelIndex] = 0; // red
      imageData.data[pixelIndex + 1] = 0; // green
      imageData.data[pixelIndex + 2] = 255 * (step / steps); // blue
      imageData.data[pixelIndex + 3] = 255; // alpha

      let nextLengthInStep = (lengthInStep === stepLength) ? 0 : lengthInStep + 1;

      if (nextLengthInStep === 0 && step === steps) {
        // We're at the boundaries of the last step.
        return;
      }

      let nextStep = (lengthInStep === stepLength) ? step + 1 : step;

      // Try to color the surrounding pixels.
      for (let i = -1; i < 2; i++) {
        for (let k = -1; k < 2; k++) {
          // if (i === 0 || k === 0 || lengthInStep % 2 === 0) {
          if (Math.random() * 30 < 10) {
            pixelDrawQueue.unshift({
              x: x + i,
              y: y + k,
              step: nextStep,
              lengthInStep: nextLengthInStep
            });
          }
        }
      }
    };

    pixelDrawQueue.unshift({
      x: centerX,
      y: centerY,
      step: 0,
      lengthInStep: 0
    });

    let counter = 0;

    while(pixelDrawQueue.length > 0) {
      const pixelToDraw = pixelDrawQueue.pop();

      const {
        x,
        y,
        step,
        lengthInStep
      } = pixelToDraw;

      if (x < 0 || y < 0 || coloredPixels[x][y] || x >= width || y >= height) {
        // This is an invalid or already colored pixel, skip drawing.
        continue;
      }

      counter++;

      drawPixelOfCircleRecursively(x, y, step, lengthInStep);
    }

    console.log('counter:', counter);

    ctx.putImageData(imageData, 0, 0);
  }

  drawCircleStep(ctx) {
    // createLinearGradient(x,y,x1,y1) - creates a linear gradient
    // createRadialGradient(x,y,r,x1,y1,r1) - creates a radial/circular gradient

    // arc(x,y,r,startAngle,endAngle,counterclockwise);

    const radius = 220;

    const circleCenterX = 300;
    const circleCenterY = 300;
    const innerRadius = 0;

    const innerCenterX = 300;
    const innerCenterY = 300;

    const outerCenterX = 300;
    const outerCenterY = 300;
    const outerRadius = 200;

    const grd = ctx.createRadialGradient(innerCenterX, innerCenterY, innerRadius, outerCenterX, outerCenterY, outerRadius);

    const { steps } = this.props;

    // const red = [255, 0, 0];
    // const green = [0, 255, 0];
    const blue = [0, 0, 255];

    // Assume at least one stop?

    // - How much color does it fall off to the next step.

    // - What is the gradient at each step.

    const innerColor = blue;
    const outerColor = [255, 255, 255];
    const colorDiff = [
      outerColor[0] - innerColor[0],
      outerColor[1] - innerColor[1],
      outerColor[2] - innerColor[2]
    ];

    // const inverseFalloff = true;
    // const gradientFalloff = 0.5 * (inverseFalloff ? -1 : 1);

    for (let i = 0; i < steps + 1; i++) {
      const floor = num => Math.floor(num);
      // const floorZero = num => Math.max(floor(num), 0);

      const r = floor(innerColor[0] + ((colorDiff[0] / steps) * i));
      const g = floor(innerColor[1] + ((colorDiff[1] / steps) * i));
      const b = floor(innerColor[2] + ((colorDiff[2] / steps) * i));

      const color = `rgb(${r}, ${g}, ${b})`;

      // const falloffR = floorZero(r - (gradientFalloff * colorDiff[0]));
      // const falloffG = floorZero(g - (gradientFalloff * colorDiff[1]));
      // const falloffB = floorZero(b - (gradientFalloff * colorDiff[2]));

      // const falloffColor = `rgb(${falloffR}, ${falloffG}, ${falloffB})`;
      grd.addColorStop(i / steps, color);
      if (i < steps) {
        const rightBeforeNextStop = ((i + 1) / steps) - 0.01;
        grd.addColorStop(rightBeforeNextStop, color);
      }
    }

    ctx.fillStyle = grd;

    const circle = new Path2D();
    circle.arc(circleCenterX, circleCenterY, radius, 0, 2 * Math.PI);

    ctx.fill(circle);
  }



    const drawBeziersOfCircleRecursively = (x, y, step) => {
      ctx.beginPath();

      // Start from a zero degree point.
      // TODO: Add rotation.
      const distanceFromCenter = 100; // (step / steps) * stepLength;
      ctx.moveTo(x + distanceFromCenter, y);

      // (4/3)*tan(pi/(2n)) = 0.5xxx
      // (4 / 3) * Math.tan(Math.PI/(2 * n));

      for (let i = 0; i < points; i++) {
        // TODO: Use translate for relative center positioning.

        const startAngle = (i === 0) ? 0 : (2 * Math.PI * (i / points));
        const stopAngle = 2 * Math.PI * ((i + 1) / points);

        const alpha = (stopAngle - startAngle) / 2;

        const cosAlpha = Math.cos(alpha);
        const sinAlpha = Math.sin(alpha);
        const cotAlpha = 1 / Math.tan(alpha);

        const phi = startAngle + alpha;
        const cosPhi = Math.cos(phi);
        const sinPhi = Math.sin(phi);

        const lambda = (4 - cosAlpha) / 3;
        const mu = (sinAlpha + (cosAlpha - lambda)) * cotAlpha;

        const cp1x = x + (((lambda * cosPhi) + (mu * sinPhi)) * distanceFromCenter);
        const cp1y = y + (((lambda * sinPhi) - (mu * cosPhi)) * distanceFromCenter);
      
        const cp2x = x + (((lambda * cosPhi) - (mu * sinPhi)) * distanceFromCenter);
        const cp2y = y + (((lambda * sinPhi) + (mu * cosPhi)) * distanceFromCenter);
        
        // ALPHA = (stopAngle - startAngle) ./ 2;
        // COS_ALPHA = cos(ALPHA);
        // SIN_ALPHA = sin(ALPHA);
        // COT_ALPHA = 1 ./ tan(ALPHA);
        // PHI = startAngle + ALPHA;
        // COS_PHI = cos(PHI);
        // SIN_PHI = sin(PHI);
        // LAMBDA = (4 - COS_ALPHA) ./ 3;
        // MU = SIN_ALPHA + (COS_ALPHA - LAMBDA) .* COT_ALPHA;

        // bezier = zeros(4,2);
        // bezier(1,1) = cos(startAngle);
        // bezier(1,2) = sin(startAngle);
        // bezier(2,1) = LAMBDA .* COS_PHI + MU .* SIN_PHI;
        // bezier(2,2) = LAMBDA .* SIN_PHI - MU .* COS_PHI;
        // bezier(3,1) = LAMBDA .* COS_PHI - MU .* SIN_PHI;
        // bezier(3,2) = LAMBDA .* SIN_PHI + MU .* COS_PHI;
        // bezier(4,1) = cos(stopAngle);
        // bezier(4,2) = sin(stopAngle);

        // Generate the control points for the bezier curve.
        // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/bezierCurveTo
        
        
        // const cp1Angle = 4 - currentAngle;
        // (4 / 3) * Math.tan(Math.PI/(2 * (i / points)));
        // const cp1x = x + (((4 - Math.cos(cp1Angle))/3) * distanceFromCenter);
        // const cp1y = y + (Math.sin(cp1Angle) * distanceFromCenter);
      
        // // const cp2Angle = (4 / 3) * Math.tan(Math.PI/(2 * (i / points)));
        // // const cp2Angle = (i === points - 1) ? 0 : (2 * Math.PI * ((i + 1) / points));
        // const cp2x = x + (((4 - Math.cos(cp2Angle))/3) * distanceFromCenter);
        // const cp2y = y + (Math.sin(cp2Angle) * distanceFromCenter);
        
        
        const endx = x + (Math.cos(stopAngle) * distanceFromCenter);
        const endy = y + (Math.sin(stopAngle) * distanceFromCenter);

        ctx.fillStyle = 'green';
        ctx.fillRect(endx - 3, endy - 3, 6, 6);

        ctx.fillStyle = 'blue';
        ctx.fillRect(cp1x - 3, cp1y - 3, 6, 6);
        ctx.fillRect(cp2x - 3, cp2y - 3, 6, 6);

        console.log(i, points, 'Start angle:', Math.floor(startAngle * (180 / Math.PI)));
        console.log(i, 'End angle:', Math.floor(stopAngle * (180 / Math.PI)));

        ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, endx, endy);
        // console.log('Position:', cp2x, cp2y);
      }

      const r = 0; // red
      const g = 0; // green
      const b = 255;// * (step / steps); // blue
      const a = 255; // alpha

      ctx.closePath();
      
      ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${a})`;
      ctx.fill();

      ctx.lineWidth = 2;
      ctx.strokeStyle = 'green';
      // ctx.stroke();
      // TODO: Add shadow.

      ctx.fillStyle = 'orange';
      ctx.fillRect(x - 3, y - 3, 6, 6);
    };

    drawBeziersOfCircleRecursively(centerX, centerY, 0);
  }







var scale = d3.scaleLinear()
  .range(["orange","steelblue","purple"])
  .domain([0,60]);
  
var data = [0,10,20,30,40,50,60];

var width = 200;
var height = 200;

var svg = d3.select("body")
  .append("svg")
  .attr("width",width)
  .attr("height",height)
  .attr("transform","translate("+width/2+","+height/2+")");
  
var circles = svg.selectAll("circle")
  .data(data)
  .enter()
  .append("circle")
  .attr("r",function(d) { return d; })
  .attr("fill","none")
  .style("stroke-width","4")
  .style("stroke",function(d) { return scale(d) });
  
function transition() {
  // Update data, max d is 60:
  data = data.map(function(d) { return d == 60 ? 0 : d + 10});
  
  var i = 0;
  // Grow circles
  circles
     .data(data)
     .filter(function(d) { return d > 0 })
     .transition()
     .ease(d3.easeLinear)
     .attr("r", function(d) { return d; })
     .style("stroke", function(d) { return scale(d) })
     .style("opacity",function(d) { return d == 60 ? 0 : 1 }) 
     .duration(1000)
     .on("end",function(){if(++i==circles.size()-1) { transition(); } });
    
     
  // Reset circles where r == 0
  circles
    .filter(function(d) { return d == 0 })
    .attr("r", 0)
    .style("opacity",1)
    .style("stroke",function(d) { return scale(d); });
     
    
}

transition();






      // Here we create a clip mask so that only the step shows up when filled.
      // This ensures we only draw the layer.
      // We use a zero pixel tunnel: https://css-tricks.com/cutting-inner-part-element-using-clip-path/
      
      let maskedPathPoints = [];
      
      if (step === 0) {
        maskedPathPoints = exteriorPathPoints;
      } else {
        for (let i = 0; i < interiorPathPoints.length; i++) {
          const point = interiorPathPoints[i];

          maskedPathPoints.push({
            type: point.type,
            x: point.x,
            y: point.y
          });
        }

        for (let i = exteriorPathPoints.length - 1; i >= 0; i--) {
          const point = exteriorPathPoints[i];
  
          maskedPathPoints.push({
            type: point.type,
            x: point.x,
            y: point.y
          });
        }

        maskedPathPoints.push({
          type: 'L',
          x: interiorPathPoints[0].x,
          y: interiorPathPoints[0].y
        });
      }







  buildSVGCircles() {
    const {
      applyShadowOnTopStep,
      centerX,
      centerY,
      colors,
      innerRadius,
      pointDeviationMaxX,
      pointDeviationMaxY,
      points,
      previousPointDeviationInfluence,
      rotateEachStep,
      rotation,
      shadowId,
      stepCenterDeviationX,
      stepCenterDeviationY,
      stepLength,
      steps,
      strokePath
    } = this.props;

    const circles = [];
    const defs = [
      <SvgShadow key="svg-shadow"/>
    ];

    const circleBase = false;

    // https://sourceforge.net/p/jsclipper/wiki/documentation/#clipperlibcliptype
    const ClipperLib = window.ClipperLib;
    let clippingFilterPoints = ClipperLib.Paths();

    let elementsAreHidden = false;

    const buildStep = (x, y, step) => {
      const interiorRadius = step * stepLength + innerRadius;
      const exteriorRadius = (step + 1) * stepLength + innerRadius;

      const interiorPathPoints = [];
      const exteriorPathPoints = [];

      const firstDeviation = {
        x: 0,
        y: 0
      };

      const previousDeviation = {
        x: 0,
        y: 0
      };

      const rotate = rotateEachStep * step + rotation;

      for (let i = 0; i < points; i++) {
        // TODO: This will have to be integrated with the store somehow.
        const pointDeviationX = Math.random() * pointDeviationMaxX - Math.random() * pointDeviationMaxX;
        const pointDeviationY = Math.random() * pointDeviationMaxY - Math.random() * pointDeviationMaxY;    

        const deviation = {
          x: pointDeviationX,
          y: pointDeviationY
        };

        if (previousPointDeviationInfluence) {
          deviation.x += previousDeviation.x;
          deviation.y += previousDeviation.y;

          // Come back to the origin when we're past the half point.
          // This prevents it making a sharp edge back to the starting location when it goes full circle.
          if (i > points - (points / 2)) {
            if (Math.abs(pointDeviationMaxX) > 0 && 
              ((pointDeviationX < 0 && previousDeviation.x > 0) || (pointDeviationX > 0 && previousDeviation.x < 0)))
            {
              const undeviateX = pointDeviationX / 2;

              deviation.x += undeviateX;
            }

            if (Math.abs(pointDeviationMaxY) > 0 && 
              ((pointDeviationY < 0 && previousDeviation.y > 0) || (pointDeviationY > 0 && previousDeviation.y < 0)))
            {
              const undeviateY = pointDeviationY / 2;

              deviation.y += undeviateY;
            }
          }
        }

        if (i === 0) {
          firstDeviation.x = deviation.x;
          firstDeviation.y = deviation.y;

          exteriorPathPoints.push(createStartPoint(exteriorRadius, rotate, deviation));
          interiorPathPoints.push(createStartPoint(interiorRadius, rotate, deviation));
        }

        // createPathPoint(radius, point, points, rotate, previousDeviation, deviation, firstDeviation)
        interiorPathPoints.push(createPathPoint(
          interiorRadius,
          i,
          points,
          rotate,
          circleBase,
          previousDeviation,
          deviation,
          firstDeviation
        ));
        exteriorPathPoints.push(createPathPoint(
          exteriorRadius,
          i,
          points,
          rotate,
          circleBase,
          previousDeviation,
          deviation,
          firstDeviation
        ));

        previousDeviation.x = deviation.x;
        previousDeviation.y = deviation.y;
      }

      // Translate the step to the center.
      for (let i = 0; i < interiorPathPoints.length; i++) {
        interiorPathPoints[i].x += x;
        interiorPathPoints[i].y += y;
        exteriorPathPoints[i].x += x;
        exteriorPathPoints[i].y += y;
      }

      const pathPointsForClip = [];

      if (step === steps - 1) {
        for (let i = interiorPathPoints.length - 1; i >= 0; i--) {
          const point = interiorPathPoints[i];
  
          pathPointsForClip.push({
            x: point.x,
            y: point.y
          });
        }
      } else {
        const pointsToAddToClip = [];
        for (let i = interiorPathPoints.length - 1; i >= 0; i--) {
          const point = interiorPathPoints[i];
  
          pointsToAddToClip.push({
            X: point.x,
            Y: point.y
          });
        }

        const clipSolution = new ClipperLib.Paths();
        const c = new ClipperLib.Clipper();
        // NOTE: If these arrays contain NaN then it will infinite loop.
        c.AddPath(pointsToAddToClip, ClipperLib.PolyType.ptSubject, true);
        c.AddPath(clippingFilterPoints, ClipperLib.PolyType.ptClip, true);
        c.Execute(ClipperLib.ClipType.ctIntersection, clipSolution);

        if (clipSolution && clipSolution.length > 0) {
          clippingFilterPoints.length = 0;
          for(let i = 0; i < clipSolution[0].length; i++) {
            clippingFilterPoints[i] = {
              X: clipSolution[0][i].X,
              Y: clipSolution[0][i].Y
            };
          }
        } else {
          elementsAreHidden = true;
        }

        // console.log('clippingFilterPoints', clippingFilterPoints);
        // const after = ClipperLib.Clipper.SimplifyPolygons([clippingFilterPoints], ClipperLib.PolyFillType.pftNonZero)[0];
        // console.log('after', after);
        // pftNonZero or pftEvenOdd

        for (let i = clippingFilterPoints.length - 1; i >= 0; i--) {
          const point = clippingFilterPoints[i];

          pathPointsForClip.push({
            x: point.X,
            y: point.Y
          });
        }
      }

      for (let i = 0; i < pathPointsForClip.length; i++) {
        const point = (step === steps - 1) ? interiorPathPoints[i] : pathPointsForClip[i];

        clippingFilterPoints[i] = {
          X: point.x,
          Y: point.y
        }
      }
      
      const pathId = `step-${step}`;
      const clipId = `clip-${pathId}`;

      defs.push(
        <clipPath
          id={clipId}
          key={clipId}
        >
          <ClipPath
            points={pathPointsForClip}
          />
        </clipPath>
      );

      const shadow = !(applyShadowOnTopStep && (step === steps - 1));

      const pathStyle = {
        fill: !strokePath ? getStepColor(step, steps, colors) : 'none',
        stroke: strokePath ? getStepColor(step, steps, colors) : 'none',
        strokeWidth: strokePath ? '1px' : '0px'
      };

      const shadowStyle = {
        fill: !strokePath ? getStepColor(step, steps, colors) : 'none',
        stroke: strokePath ? getStepColor(step, steps, colors) : 'none'
      }

      circles.push(
        <Path
          clipId={`clip-step-${step}`}
          key={pathId}
          id={pathId}
          pathPoints={strokePath ? interiorPathPoints : exteriorPathPoints}
          shadowPathPoints={strokePath ? (shadow && exteriorPathPoints) : (shadow && pathPointsForClip)}
          shadowId={shadow && shadowId}
          shadowStyle={shadowStyle}
          step={step}
          style={pathStyle}
        />
      );
    };

    for (let i = steps - 1; i >= 0; i--) {
      if (elementsAreHidden) {
        break;
      }

      buildStep(centerX + (steps - i) * stepCenterDeviationX, centerY + (steps - i) * stepCenterDeviationY, i);
    }

    return [
      <defs key="svg-defs">
        {defs}
      </defs>,
      circles
    ];
  }
