  drawCircle(ctx) {
    const {
      height,
      steps,
      width
    } = this.props;

    const coloredPixels = [];
    for (let i = 0; i < width; i++) {
      coloredPixels[i] = [];
    }

    // First we color the inner radius fully.
    
    // const innerRadius = 30;

    // const radius = 220;

    const centerX = 200;
    const centerY = 200;

    const stepLength = 30;

    const imageData = ctx.createImageData(width, height);

    console.log('Drawing a circle centered at', centerX, centerY);
    console.log('With a radius of', stepLength * steps);
    console.log('In an array the size of', width, height);

    const pixelDrawQueue = [];

    const drawPixelOfCircleRecursively = (x, y, step, lengthInStep) => {
      // Mark this pixel as painted.
      coloredPixels[x][y] = true;

      // if (Math.random()* 100 > 99) {
      //   console.log('Drawing', x, y);
      // }

      const pixelIndex = (y * width + x) * 4;
      
      // console.log('Color pixel at index:', x, y);

      imageData.data[pixelIndex] = 0; // red
      imageData.data[pixelIndex + 1] = 0; // green
      imageData.data[pixelIndex + 2] = 255 * (step / steps); // blue
      imageData.data[pixelIndex + 3] = 255; // alpha

      let nextLengthInStep = (lengthInStep === stepLength) ? 0 : lengthInStep + 1;

      if (nextLengthInStep === 0 && step === steps) {
        // We're at the boundaries of the last step.
        return;
      }

      let nextStep = (lengthInStep === stepLength) ? step + 1 : step;

      // Try to color the surrounding pixels.
      for (let i = -1; i < 2; i++) {
        for (let k = -1; k < 2; k++) {
          // if (i === 0 || k === 0 || lengthInStep % 2 === 0) {
          if (Math.random() * 30 < 10) {
            pixelDrawQueue.unshift({
              x: x + i,
              y: y + k,
              step: nextStep,
              lengthInStep: nextLengthInStep
            });
          }
        }
      }
    };

    pixelDrawQueue.unshift({
      x: centerX,
      y: centerY,
      step: 0,
      lengthInStep: 0
    });

    let counter = 0;

    while(pixelDrawQueue.length > 0) {
      const pixelToDraw = pixelDrawQueue.pop();

      const {
        x,
        y,
        step,
        lengthInStep
      } = pixelToDraw;

      if (x < 0 || y < 0 || coloredPixels[x][y] || x >= width || y >= height) {
        // This is an invalid or already colored pixel, skip drawing.
        continue;
      }

      counter++;

      drawPixelOfCircleRecursively(x, y, step, lengthInStep);
    }

    console.log('counter:', counter);

    ctx.putImageData(imageData, 0, 0);
  }

  drawCircleStep(ctx) {
    // createLinearGradient(x,y,x1,y1) - creates a linear gradient
    // createRadialGradient(x,y,r,x1,y1,r1) - creates a radial/circular gradient

    // arc(x,y,r,startAngle,endAngle,counterclockwise);

    const radius = 220;

    const circleCenterX = 300;
    const circleCenterY = 300;
    const innerRadius = 0;

    const innerCenterX = 300;
    const innerCenterY = 300;

    const outerCenterX = 300;
    const outerCenterY = 300;
    const outerRadius = 200;

    const grd = ctx.createRadialGradient(innerCenterX, innerCenterY, innerRadius, outerCenterX, outerCenterY, outerRadius);

    const { steps } = this.props;

    // const red = [255, 0, 0];
    // const green = [0, 255, 0];
    const blue = [0, 0, 255];

    // Assume at least one stop?

    // - How much color does it fall off to the next step.

    // - What is the gradient at each step.

    const innerColor = blue;
    const outerColor = [255, 255, 255];
    const colorDiff = [
      outerColor[0] - innerColor[0],
      outerColor[1] - innerColor[1],
      outerColor[2] - innerColor[2]
    ];

    // const inverseFalloff = true;
    // const gradientFalloff = 0.5 * (inverseFalloff ? -1 : 1);

    for (let i = 0; i < steps + 1; i++) {
      const floor = num => Math.floor(num);
      // const floorZero = num => Math.max(floor(num), 0);

      const r = floor(innerColor[0] + ((colorDiff[0] / steps) * i));
      const g = floor(innerColor[1] + ((colorDiff[1] / steps) * i));
      const b = floor(innerColor[2] + ((colorDiff[2] / steps) * i));

      const color = `rgb(${r}, ${g}, ${b})`;

      // const falloffR = floorZero(r - (gradientFalloff * colorDiff[0]));
      // const falloffG = floorZero(g - (gradientFalloff * colorDiff[1]));
      // const falloffB = floorZero(b - (gradientFalloff * colorDiff[2]));

      // const falloffColor = `rgb(${falloffR}, ${falloffG}, ${falloffB})`;
      grd.addColorStop(i / steps, color);
      if (i < steps) {
        const rightBeforeNextStop = ((i + 1) / steps) - 0.01;
        grd.addColorStop(rightBeforeNextStop, color);
      }
    }

    ctx.fillStyle = grd;

    const circle = new Path2D();
    circle.arc(circleCenterX, circleCenterY, radius, 0, 2 * Math.PI);

    ctx.fill(circle);
  }



    const drawBeziersOfCircleRecursively = (x, y, step) => {
      ctx.beginPath();

      // Start from a zero degree point.
      // TODO: Add rotation.
      const distanceFromCenter = 100; // (step / steps) * stepLength;
      ctx.moveTo(x + distanceFromCenter, y);

      // (4/3)*tan(pi/(2n)) = 0.5xxx
      // (4 / 3) * Math.tan(Math.PI/(2 * n));

      for (let i = 0; i < points; i++) {
        // TODO: Use translate for relative center positioning.

        const startAngle = (i === 0) ? 0 : (2 * Math.PI * (i / points));
        const stopAngle = 2 * Math.PI * ((i + 1) / points);

        const alpha = (stopAngle - startAngle) / 2;

        const cosAlpha = Math.cos(alpha);
        const sinAlpha = Math.sin(alpha);
        const cotAlpha = 1 / Math.tan(alpha);

        const phi = startAngle + alpha;
        const cosPhi = Math.cos(phi);
        const sinPhi = Math.sin(phi);

        const lambda = (4 - cosAlpha) / 3;
        const mu = (sinAlpha + (cosAlpha - lambda)) * cotAlpha;

        const cp1x = x + (((lambda * cosPhi) + (mu * sinPhi)) * distanceFromCenter);
        const cp1y = y + (((lambda * sinPhi) - (mu * cosPhi)) * distanceFromCenter);
      
        const cp2x = x + (((lambda * cosPhi) - (mu * sinPhi)) * distanceFromCenter);
        const cp2y = y + (((lambda * sinPhi) + (mu * cosPhi)) * distanceFromCenter);
        
        // ALPHA = (stopAngle - startAngle) ./ 2;
        // COS_ALPHA = cos(ALPHA);
        // SIN_ALPHA = sin(ALPHA);
        // COT_ALPHA = 1 ./ tan(ALPHA);
        // PHI = startAngle + ALPHA;
        // COS_PHI = cos(PHI);
        // SIN_PHI = sin(PHI);
        // LAMBDA = (4 - COS_ALPHA) ./ 3;
        // MU = SIN_ALPHA + (COS_ALPHA - LAMBDA) .* COT_ALPHA;

        // bezier = zeros(4,2);
        // bezier(1,1) = cos(startAngle);
        // bezier(1,2) = sin(startAngle);
        // bezier(2,1) = LAMBDA .* COS_PHI + MU .* SIN_PHI;
        // bezier(2,2) = LAMBDA .* SIN_PHI - MU .* COS_PHI;
        // bezier(3,1) = LAMBDA .* COS_PHI - MU .* SIN_PHI;
        // bezier(3,2) = LAMBDA .* SIN_PHI + MU .* COS_PHI;
        // bezier(4,1) = cos(stopAngle);
        // bezier(4,2) = sin(stopAngle);

        // Generate the control points for the bezier curve.
        // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/bezierCurveTo
        
        
        // const cp1Angle = 4 - currentAngle;
        // (4 / 3) * Math.tan(Math.PI/(2 * (i / points)));
        // const cp1x = x + (((4 - Math.cos(cp1Angle))/3) * distanceFromCenter);
        // const cp1y = y + (Math.sin(cp1Angle) * distanceFromCenter);
      
        // // const cp2Angle = (4 / 3) * Math.tan(Math.PI/(2 * (i / points)));
        // // const cp2Angle = (i === points - 1) ? 0 : (2 * Math.PI * ((i + 1) / points));
        // const cp2x = x + (((4 - Math.cos(cp2Angle))/3) * distanceFromCenter);
        // const cp2y = y + (Math.sin(cp2Angle) * distanceFromCenter);
        
        
        const endx = x + (Math.cos(stopAngle) * distanceFromCenter);
        const endy = y + (Math.sin(stopAngle) * distanceFromCenter);

        ctx.fillStyle = 'green';
        ctx.fillRect(endx - 3, endy - 3, 6, 6);

        ctx.fillStyle = 'blue';
        ctx.fillRect(cp1x - 3, cp1y - 3, 6, 6);
        ctx.fillRect(cp2x - 3, cp2y - 3, 6, 6);

        console.log(i, points, 'Start angle:', Math.floor(startAngle * (180 / Math.PI)));
        console.log(i, 'End angle:', Math.floor(stopAngle * (180 / Math.PI)));

        ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, endx, endy);
        // console.log('Position:', cp2x, cp2y);
      }

      const r = 0; // red
      const g = 0; // green
      const b = 255;// * (step / steps); // blue
      const a = 255; // alpha

      ctx.closePath();
      
      ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${a})`;
      ctx.fill();

      ctx.lineWidth = 2;
      ctx.strokeStyle = 'green';
      // ctx.stroke();
      // TODO: Add shadow.

      ctx.fillStyle = 'orange';
      ctx.fillRect(x - 3, y - 3, 6, 6);
    };

    drawBeziersOfCircleRecursively(centerX, centerY, 0);
  }